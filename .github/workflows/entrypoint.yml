---
name: 'Organization Quality Checks Orchestrator'

on:  # yamllint disable-line rule:truthy
  workflow_call:
    inputs:
      run-basic-checks:
        description: 'Whether to run the basic PR quality checks.'
        required: false
        type: boolean
        default: true
      run-python-checks:
        description: 'Whether to run the Python code quality checks.'
        required: false
        type: boolean
        default: false
      python-version:
        description: 'The Python version to use for the Python checks.'
        required: false
        type: string
        default: '3.11'
      run-config-checks:
        description: 'Whether to run the configuration files quality checks.'
        required: false
        type: boolean
        default: false
      run-frontend-checks:
        description: 'Whether to run the frontend code quality checks.'
        required: false
        type: boolean
        default: false
      run-go-checks:
        description: 'Whether to run the Golang code quality checks.'
        required: false
        type: boolean
        default: false
      go-version:
        description: 'The Go version to use.'
        required: false
        type: string
        default: 'stable'
      go-working-directory:
        description: 'Working directory for Go checks.'
        required: false
        type: string
        default: '.'
    secrets:
      CHECKER_TOKEN:
        description: 'The GITHUB_TOKEN passed from the caller.'
        required: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

jobs:
  call-basic-checks:
    name: Run Basic PR Quality Checks
    if: inputs.run-basic-checks
    uses: ./.github/workflows/reusables-basic.yml
    secrets:
      CHECKER_TOKEN: ${{ secrets.CHECKER_TOKEN }}

  call-python-checks:
    name: Run Python Quality Checks
    if: inputs.run-python-checks
    uses: ./.github/workflows/reusables-python.yml
    with:
      python-version: ${{ inputs.python-version }}
    secrets:
      CHECKER_TOKEN: ${{ secrets.CHECKER_TOKEN }}

  call-config-checks:
    name: Run Configuration Files Quality Checks
    if: inputs.run-config-checks
    uses: ./.github/workflows/reusables-config.yml
    secrets:
      CHECKER_TOKEN: ${{ secrets.CHECKER_TOKEN }}

  call-frontend-checks:
    name: Run Frontend Quality Checks
    if: inputs.run-frontend-checks
    uses: ./.github/workflows/reusables-frontend.yml
    secrets:
      CHECKER_TOKEN: ${{ secrets.CHECKER_TOKEN }}

  call-go-checks:
    name: Run Go Quality Checks
    if: inputs.run-go-checks
    uses: ./.github/workflows/reusables-go.yml
    with:
      go-version: ${{ inputs.go-version }}
      working-directory: ${{ inputs.go-working-directory }}
    secrets:
      CHECKER_TOKEN: ${{ secrets.CHECKER_TOKEN }}

  report-summary:
    name: Report Overall Summary
    runs-on: ubuntu-latest
    needs:
      - call-basic-checks
      - call-python-checks
      - call-config-checks
      - call-frontend-checks
      - call-go-checks
    if: always()  # This job runs even if previous jobs fail
    steps:
      - name: Build and Post Comment
        id: build_comment
        uses: actions/github-script@v7
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
        with:
          github-token: ${{ secrets.CHECKER_TOKEN }}
          script: |
            const needs = JSON.parse(process.env.NEEDS_CONTEXT);
            let comment_body = "### üõ°Ô∏è PR Quality Check Summary\n\n";
            let all_passed = true;
            let anyJobRan = false;

            // Helper to check job status
            const wasJobRun = (job) => job && job.result !== 'skipped';

            // Helper to safely get output value
            const getOutput = (outputs, key, defaultValue = 'N/A') => {
              return outputs?.[key] || defaultValue;
            };

            // --- Basic Checks ---
            if (wasJobRun(needs['call-basic-checks'])) {
              anyJobRan = true;
              const { outputs } = needs['call-basic-checks'];

              // Only add summaries if they exist
              if (outputs) {
                const prTitleSum = 'pr-title-summary';
                const branchNameSum = 'branch-name-summary';
                const commitMsgSum = 'commit-messages-summary';
                const conflictsSum = 'conflicts-summary';

                comment_body += getOutput(outputs, prTitleSum,
                  '‚ö†Ô∏è **PR Title:** No output received') + "\n";
                comment_body += getOutput(outputs, branchNameSum,
                  '‚ö†Ô∏è **Branch Name:** No output received') + "\n";
                comment_body += getOutput(outputs, commitMsgSum,
                  '‚ö†Ô∏è **Commit Messages:** No output received') + "\n";
                comment_body += getOutput(outputs, conflictsSum,
                  '‚ö†Ô∏è **Conflicts:** No output received') + "\n";

                if (getOutput(outputs, 'pr-title-status') === 'failure' ||
                    getOutput(outputs, 'branch-name-status') === 'failure' ||
                    getOutput(outputs, 'commit-messages-status')
                      === 'failure' ||
                    getOutput(outputs, 'conflicts-status') === 'failure') {
                  all_passed = false;
                }
              } else {
                comment_body += "‚ö†Ô∏è **Basic Checks:** " +
                  "Completed but no outputs received\n";
              }
            }

            // --- Python Checks ---
            if (wasJobRun(needs['call-python-checks'])) {
              anyJobRan = true;
              const { outputs } = needs['call-python-checks'];

              if (outputs) {
                comment_body += getOutput(outputs, 'python-summary',
                  '‚ö†Ô∏è **Python Quality:** No output received') + "\n";
                if (getOutput(outputs, 'python-status') === 'failure') {
                  all_passed = false;
                }
              } else {
                comment_body += "‚ö†Ô∏è **Python Checks:** " +
                  "Completed but no outputs received\n";
              }
            }

            // --- Config Checks ---
            if (wasJobRun(needs['call-config-checks'])) {
              anyJobRan = true;
              const { outputs } = needs['call-config-checks'];

              if (outputs) {
                comment_body += getOutput(outputs, 'yaml-summary',
                  '‚ö†Ô∏è **YAML Files:** No output received') + "\n";
                comment_body += getOutput(outputs, 'json-summary',
                  '‚ö†Ô∏è **JSON Files:** No output received') + "\n";
                comment_body += getOutput(outputs, 'toml-summary',
                  '‚ö†Ô∏è **TOML Files:** No output received') + "\n";

                if (getOutput(outputs, 'yaml-status') === 'failure' ||
                    getOutput(outputs, 'json-status') === 'failure' ||
                    getOutput(outputs, 'toml-status') === 'failure') {
                  all_passed = false;
                }
              } else {
                comment_body += "‚ö†Ô∏è **Config Checks:** " +
                  "Completed but no outputs received\n";
              }
            }

            // --- Frontend Checks ---
            if (wasJobRun(needs['call-frontend-checks'])) {
              anyJobRan = true;
              const { outputs } = needs['call-frontend-checks'];

              if (outputs) {
                comment_body += getOutput(outputs, 'prettier-summary',
                  '‚ö†Ô∏è **Prettier:** No output received') + "\n";
                comment_body += getOutput(outputs, 'eslint-summary',
                  '‚ö†Ô∏è **ESLint:** No output received') + "\n";
                // comment_body += getOutput(outputs, 'typescript-summary',
                //   '‚ö†Ô∏è **TypeScript:** No output received') + "\n";
                if (getOutput(outputs, 'prettier-status') === 'failure' ||
                    getOutput(outputs, 'eslint-status') === 'failure' ) {
                    // getOutput(outputs, 'typescript-status') === 'failure') {
                  all_passed = false;
                }
              } else {
                comment_body += "‚ö†Ô∏è **Frontend Checks:** " +
                  "Completed but no outputs received\n";
              }
            }

            // --- Go Checks ---
            if (wasJobRun(needs['call-go-checks'])) {
              anyJobRan = true;
              const { outputs } = needs['call-go-checks'];

              if (outputs) {
                comment_body += getOutput(outputs, 'go-summary',
                  '‚ö†Ô∏è **Go Quality:** No output received') + "\n";
                if (getOutput(outputs, 'go-status') === 'failure') {
                  all_passed = false;
                }
              } else {
                comment_body += "‚ö†Ô∏è **Go Checks:** " +
                  "Completed but no outputs received\n";
              }
            }

            // --- Detailed Reports ---
            if (wasJobRun(needs['call-basic-checks']) &&
                needs['call-basic-checks']?.outputs?.['commit-messages-status']
                  === 'failure') {
              const report = needs['call-basic-checks']?.outputs?.[
                'commit-messages-report'
              ];
              if (report) {
                comment_body += `\n<details><summary>üìã Click for detailed ` +
                  `commit validation report</summary>\n\n\`\`\`\n${report}` +
                  `\n\`\`\`\n\n</details>\n`;
              }
            }

            // --- Final Status ---
            comment_body += "\n---\n";

            if (!anyJobRan) {
              comment_body += "‚ö†Ô∏è **No checks were executed.** " +
                "Both check suites were skipped or disabled.";
            } else if (all_passed) {
              comment_body += "üéâ **All checks passed!**";
            } else {
              comment_body += "‚ö†Ô∏è **Please fix the failing checks (‚ùå) " +
                "before merging.**";
            }

            // --- Update or Create Comment ---
            try {
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              const botComment = comments.data.find(comment =>
                comment.user.type === 'Bot' &&
                comment.body.includes('üõ°Ô∏è PR Quality Check Summary')
              );

              // 1. Â¶ÇÊûúÊâæÂà∞ËàäÁïôË®ÄÔºåÂ∞±Âà™Èô§ÂÆÉ
              if (botComment) {
                await github.rest.issues.deleteComment({
                  comment_id: botComment.id,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                });
                console.log(`‚úÖ Deleted existing comment #${botComment.id}`);
              }

              // 2. ÁÑ°Ë´ñÂ¶Ç‰ΩïÔºåÈÉΩÂú®ÊúÄÂ∫ï‰∏ãÂª∫Á´ã‰∏ÄÂâáÊñ∞ÁïôË®Ä
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment_body
              });
              console.log('‚úÖ Created new comment at the bottom');

            } catch (error) {
              core.setFailed(`Failed to post comment: ${error.message}`);
              console.error('Comment body that failed to post:', comment_body);
              throw error;
            }

            core.setOutput('all_passed', all_passed);

      - name: Fail workflow if any check failed
        if: steps.build_comment.outputs.all_passed == 'false'
        run: |
          echo "‚ùå One or more PR quality checks failed. " \
               "See summary comment for details."
          exit 1
