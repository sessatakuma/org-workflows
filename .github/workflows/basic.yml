name: 'Basic Code Quality Checks'

on:
  workflow_call:
    secrets:
      CHECKER_TOKEN:
        description: 'The GITHUB_TOKEN passed from the caller'
        required: true

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  TYPES: "feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert"
  MAX_LENGTH: 75

jobs:
  check-commits:
    name: 'Check Commit Messages'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
      report: ${{ steps.check.outputs.report }}
    steps:
      - name: Checkout Caller Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}

      - name: Check Commit Messages Format
        id: check
        run: |
          REGEX="^(${{ env.TYPES }})(\(.+\))?:\s.+"
          
          COMMITS=$(git log --format="%H:::%s" ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})
          
          FAILED_COMMITS_REPORT=""
          TOTAL_COMMITS=0
          FAILED_COUNT=0
          
          while IFS= read -r line; do
            if [ -z "$line" ]; then
              continue
            fi
            
            TOTAL_COMMITS=$((TOTAL_COMMITS + 1))
            COMMIT_SHA=$(echo "$line" | cut -d':' -f1 | cut -c1-7)
            COMMIT_MSG=$(echo "$line" | cut -d':' -f4-)
            
            ERRORS=""
            
            # 1. Length Check
            if [ "${#COMMIT_MSG}" -gt "${{ env.MAX_LENGTH }}" ]; then
              ERRORS="${ERRORS}  ‚Ü≥ Title is too long (is **${#COMMIT_MSG}** chars, max is **${{ env.MAX_LENGTH }}**)\n"
            fi
            
            # 2. Format Check
            if [[ ! "$COMMIT_MSG" =~ $REGEX ]]; then
              if [[ ! "$COMMIT_MSG" =~ : ]]; then
                ERRORS="${ERRORS}  ‚Ü≥ Missing ':' separator\n"
              elif [[ ! "$COMMIT_MSG" =~ ^(${{ env.TYPES }}) ]]; then
                ERRORS="${ERRORS}  ‚Ü≥ Invalid type prefix\n"
              elif [[ "$COMMIT_MSG" =~ ^(${{ env.TYPES }})(\(.+\))?:[[:space:]]*$ ]]; then
                ERRORS="${ERRORS}  ‚Ü≥ Missing description after ':'\n"
              else
                ERRORS="${ERRORS}  ‚Ü≥ Invalid format\n"
              fi
            fi
            
            # 3. Lowercase Check
            DESC=$(echo "$COMMIT_MSG" | sed -E "s/^(${{ env.TYPES }})(\(.+\))?:\s+//")
            if [[ ! "$DESC" =~ ^[a-z] ]]; then
              ERRORS="${ERRORS}  ‚Ü≥ Description must start with a lowercase letter\n"
            fi
            
            if [ -n "$ERRORS" ]; then
              FAILED_COUNT=$((FAILED_COUNT + 1))
              FAILED_COMMITS_REPORT="${FAILED_COMMITS_REPORT}- [\`${COMMIT_SHA}\`] \`${COMMIT_MSG}\`\n${ERRORS}"
            fi
          done <<< "$COMMITS"
          
          if [ "$FAILED_COUNT" -eq 0 ]; then
            MESSAGE="‚úÖ **Commit Messages:** All $TOTAL_COMMITS commit(s) passed (Length, Format, Case)"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            echo "report=" >> $GITHUB_OUTPUT
          else
            MESSAGE="‚ùå **Commit Messages:** $FAILED_COUNT of $TOTAL_COMMITS commit(s) failed validation"
            REPORT="Expected format: \`type(scope): description\` (max ${{ env.MAX_LENGTH }} chars)\n"
            REPORT+="Valid types: ${{ env.TYPES }}\n\n"
            REPORT+="Failed commits:\n"
            REPORT+="$FAILED_COMMITS_REPORT"
            
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            echo "report<<EOF" >> $GITHUB_OUTPUT
            echo -e "$REPORT"
            echo "EOF" >> $GITHUB_OUTPUT
          fi

  check-conflicts:
    name: 'Check Merge Conflicts'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Check for conflict markers
        id: check
        run: |
          CONFLICT_FILES=$(grep -r -n -E '<<<<<<<|=======|>>>>>>>' \
            --exclude-dir=.git \
            --exclude-dir=node_modules \
            . 2>/dev/null || true)
          
          if [ -n "$CONFLICT_FILES" ]; then
            FIRST_FILE=$(echo "$CONFLICT_FILES" | head -n 1 | cut -d: -f1)
            FILE_COUNT=$(echo "$CONFLICT_FILES" | cut -d: -f1 | sort -u | wc -l)
            MESSAGE="‚ùå **Conflicts:** Found unresolved merge markers in $FILE_COUNT file(s) (e.g., \`$FIRST_FILE\`)"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi

          MESSAGE="‚úÖ **Conflicts:** No merge conflict markers found"
          echo "$MESSAGE"
          echo "status=success" >> $GITHUB_OUTPUT
          echo "summary=$MESSAGE" >> $GITHUB_OUTPUT

  check-pr-title:
    name: 'Check PR Title'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
    steps:
      - name: Check PR Title Format
        id: check
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          TITLE_LENGTH=${#PR_TITLE}
          
          # Length Check
          if [ "$TITLE_LENGTH" -gt "${{ env.MAX_LENGTH }}" ]; then
            MESSAGE="‚ùå **PR Title:** Title is too long (is **$TITLE_LENGTH** chars, max is **${{ env.MAX_LENGTH }}**). Current: \`$PR_TITLE\`"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Format Check
          REGEX="^(${{ env.TYPES }})(\(.+\))?:\s.+"

          if [[ ! "$PR_TITLE" =~ $REGEX ]]; then
            if [[ ! "$PR_TITLE" =~ : ]]; then
              ERROR_DETAIL="Missing ':' separator"
            elif [[ ! "$PR_TITLE" =~ ^(${{ env.TYPES }}) ]]; then
              ERROR_DETAIL="Invalid or missing type prefix (must be one of: ${{ env.TYPES }})"
            elif [[ "$PR_TITLE" =~ ^(${{ env.TYPES }})(\(.+\))?:[[:space:]]*$ ]]; then
              ERROR_DETAIL="Missing description after ':'"
            else
              ERROR_DETAIL="Invalid format"
            fi
            
            MESSAGE="‚ùå **PR Title:** $ERROR_DETAIL. Current: \`$PR_TITLE\`. Expected: \`type: description\` (e.g., \`feat: add new feature\`)"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Lowercase Check
          DESC=$(echo "$PR_TITLE" | sed -E "s/^(${{ env.TYPES }})(\(.+\))?:\s+//")
          if [[ ! "$DESC" =~ ^[a-z] ]]; then
            MESSAGE="‚ùå **PR Title:** Description must start with a lowercase letter. Current: \`$PR_TITLE\`"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Success
          MESSAGE="‚úÖ **PR Title:** Passed (Length: $TITLE_LENGTH/${{ env.MAX_LENGTH }}, Format: OK). \`$PR_TITLE\`"
          echo "$MESSAGE"
          echo "status=success" >> $GITHUB_OUTPUT
          echo "summary=$MESSAGE" >> $GITHUB_OUTPUT

  check-branch-name:
    name: 'Check Branch Name'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
    steps:
      - name: Check Branch Name Format
        id: check
        run: |
          BRANCH_NAME="${{ github.head_ref }}"

          if [[ "$BRANCH_NAME" = "dev" ]]; then
            MESSAGE="‚úÖ **Branch Name:** Valid special branch (\`$BRANCH_NAME\`)"
            echo "$MESSAGE"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi

          FULL_REGEX="^(${{ env.TYPES }})\/[a-z0-9-]+$"

          if [[ ! "$BRANCH_NAME" =~ / ]]; then
            MESSAGE="‚ùå **Branch Name:** Missing '/' separator. Current: \`$BRANCH_NAME\`. Expected: \`type/description\`"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ ! "$BRANCH_NAME" =~ ^(${{ env.TYPES }})\/ ]]; then
            MESSAGE="‚ùå **Branch Name:** Invalid type prefix. Current: \`$BRANCH_NAME\`. Must start with one of: \`${{ env.TYPES }}\`"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ ! "$BRANCH_NAME" =~ $FULL_REGEX ]]; then
            MESSAGE="‚ùå **Branch Name:** Invalid format after '/'. Must be lowercase alphanumeric and hyphens. Current: \`$BRANCH_NAME\`"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi

          MESSAGE="‚úÖ **Branch Name:** Follows naming convention (\`$BRANCH_NAME\`)"
          echo "$MESSAGE"
          echo "status=success" >> $GITHUB_OUTPUT
          echo "summary=$MESSAGE" >> $GITHUB_OUTPUT

  report-summary:
    name: 'Report Summary'
    runs-on: ubuntu-latest
    needs:
      - check-commits
      - check-conflicts
      - check-pr-title
      - check-branch-name
    if: always()
    steps:
      - name: Build and Post Comment
        id: build_comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CHECKER_TOKEN }}
          script: |
            const outputs = {
              title: {
                status: ${{ toJSON(needs.check-pr-title.outputs.status) }},
                summary: ${{ toJSON(needs.check-pr-title.outputs.summary) }}
              },
              branch: {
                status: ${{ toJSON(needs.check-branch-name.outputs.status) }},
                summary: ${{ toJSON(needs.check-branch-name.outputs.summary) }}
              },
              commit: {
                status: ${{ toJSON(needs.check-commits.outputs.status) }},
                summary: ${{ toJSON(needs.check-commits.outputs.summary) }},
                report: ${{ toJSON(needs.check-commits.outputs.report) }}
              },
              conflicts: {
                status: ${{ toJSON(needs.check-conflicts.outputs.status) }},
                summary: ${{ toJSON(needs.check-conflicts.outputs.summary) }}
              }
            };
            
            let all_passed = true;
            let comment_body = "### üõ°Ô∏è PR Quality Check Summary\n\n";
            
            // Display the check results in order (using the summary generated by each job)
            comment_body += outputs.title.summary + "\n";
            comment_body += outputs.branch.summary + "\n";
            comment_body += outputs.commit.summary + "\n";
            comment_body += outputs.conflicts.summary + "\n";
            
            // Determine overall pass/fail
            if (outputs.title.status === 'failure' || 
                outputs.branch.status === 'failure' || 
                outputs.commit.status === 'failure' || 
                outputs.conflicts.status === 'failure') {
              all_passed = false;
            }

            // If commit validation failed, add detailed report in a collapsible section
            if (outputs.commit.status === 'failure' && outputs.commit.report) {
              comment_body += "\n<details><summary>üìã Click for detailed commit validation report</summary>\n\n";
              comment_body += "```\n" + outputs.commit.report + "\n```\n";
              comment_body += "</details>\n";
            }

            // Final overall status message
            if (all_passed) {
              comment_body += "\n---\nüéâ **All checks passed!** Ready to merge.";
            } else {
              comment_body += "\n---\n‚ö†Ô∏è **Please fix the failing checks (‚ùå) before merging.**";
            }
            
            // Find existing comment and update to avoid duplication
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('üõ°Ô∏è PR Quality Check Summary')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment_body
              });
              console.log('‚úÖ Updated existing comment');
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment_body
              });
              console.log('‚úÖ Created new comment');
            }
            
            core.setOutput('all_passed', all_passed ? 'true' : 'false');

      - name: Fail workflow if any check failed
        if: steps.build_comment.outputs.all_passed == 'false'
        run: |
          echo "‚ùå One or more PR quality checks failed. See summary comment for details."
          exit 1