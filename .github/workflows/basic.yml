name: 'Basic Code Quality Checks'

on:
  workflow_call:
    secrets:
      CHECKER_TOKEN:
        description: 'The GITHUB_TOKEN passed from the caller'
        required: true

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-commits:
    name: 'Check Commit Messages'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
      report: ${{ steps.check.outputs.report }}
    steps:
      - name: Checkout Caller Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}

      - name: Checkout org-workflows Repo
        uses: actions/checkout@v4
        with:
          repository: sessatakuma/org-workflows
          path: '.org-workflows'
          token: ${{ secrets.CHECKER_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install commitlint dependencies
        run: |
          if [ ! -f package.json ]; then
            echo "❌ Error: package.json not found"
            exit 1
          fi
          npm install
        working-directory: .org-workflows/.github/configs/commitlint/

      - name: Run commitlint
        id: check
        run: |
          set +e
          
          # Run commitlint and capture output
          LINT_OUTPUT=$(npx commitlint \
            --config ../commitlint.config.js \
            --from=${{ github.event.pull_request.base.sha }} \
            --to=${{ github.event.pull_request.head.sha }} \
            --verbose 2>&1)
          EXIT_CODE=$?
          
          # Count total commits
          TOTAL_COMMITS=$(git log --oneline ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }} | wc -l)
          
          set -e

          if [ "$EXIT_CODE" -eq 0 ]; then
            MESSAGE="✅ **Commit Messages:** All $TOTAL_COMMITS commit(s) follow the conventional format"
            echo "$MESSAGE"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            echo "report=" >> $GITHUB_OUTPUT
          else
            # Extract error count from commitlint output
            ERROR_COUNT=$(echo "$LINT_OUTPUT" | grep -oP '\d+(?= problems?)' | head -n 1 || echo "some")
            
            # Build a clean error report
            REPORT="Expected format: \`type(scope): description\`"
            REPORT="${REPORT}"$'\n'"Valid types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert"
            REPORT="${REPORT}"$'\n'$'\n'"Failed commits:"
            
            # Extract failed commit info (lines starting with ⧗ or containing errors)
            while IFS= read -r line; do
              # Match lines with commit hash and subject
              if echo "$line" | grep -qE "^⧗   input:"; then
                COMMIT_MSG=$(echo "$line" | sed 's/^⧗   input: //')
                REPORT="${REPORT}"$'\n'"- \`${COMMIT_MSG}\`"
              elif echo "$line" | grep -qE "✖"; then
                ERROR_MSG=$(echo "$line" | sed -E 's/^[[:space:]]*✖[[:space:]]*//' | sed 's/\[.*\]//')
                REPORT="${REPORT}"$'\n'"  ↳ ${ERROR_MSG}"
              fi
            done <<< "$LINT_OUTPUT"
            
            MESSAGE="❌ **Commit Messages:** $ERROR_COUNT of $TOTAL_COMMITS commit(s) have invalid format"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            echo "report<<EOF" >> $GITHUB_OUTPUT
            echo "$REPORT"
            echo "EOF" >> $GITHUB_OUTPUT
          fi
        working-directory: .org-workflows/.github/configs/commitlint/

  check-conflicts:
    name: 'Check Merge Conflicts'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Check for conflict markers
        id: check
        run: |
          CONFLICT_FILES=$(grep -r -n -E '<<<<<<<|=======|>>>>>>>' \
            --exclude-dir=.git \
            --exclude-dir=node_modules \
            . 2>/dev/null || true)
          
          if [ -n "$CONFLICT_FILES" ]; then
            FIRST_FILE=$(echo "$CONFLICT_FILES" | head -n 1 | cut -d: -f1)
            FILE_COUNT=$(echo "$CONFLICT_FILES" | cut -d: -f1 | sort -u | wc -l)
            MESSAGE="❌ **Conflicts:** Found unresolved merge markers in $FILE_COUNT file(s) (e.g., \`$FIRST_FILE\`)"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary<<EOF" >> $GITHUB_OUTPUT
            echo "$MESSAGE"
            echo "EOF" >> $GITHUB_OUTPUT
          else
            MESSAGE="✅ **Conflicts:** No merge conflict markers found"
            echo "$MESSAGE"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
          fi

  check-pr-title:
    name: 'Check PR Title'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
    steps:
      - name: Check PR Title Format
        id: check
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          
          # Conventional commit types
          TYPES="feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert"
          
          # Regex: type(optional-scope): description
          # Examples: "feat: add feature", "fix(api): bug fix", "docs: update readme"
          REGEX="^($TYPES)(\(.+\))?:\s.+"
          
          if [[ "$PR_TITLE" =~ $REGEX ]]; then
            # Check that description starts with lowercase
            DESC=$(echo "$PR_TITLE" | sed -E "s/^($TYPES)(\(.+\))?:\s+//")
            if [[ "$DESC" =~ ^[a-z] ]]; then
              MESSAGE="✅ **PR Title:** Follows conventional format (\`$PR_TITLE\`)"
              echo "$MESSAGE"
              echo "status=success" >> $GITHUB_OUTPUT
              echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            else
              MESSAGE="❌ **PR Title:** Description should start with lowercase. Current: \`$PR_TITLE\`. Expected: \`type: description\` (e.g., \`feat: add new feature\`)"
              echo "$MESSAGE"
              echo "status=failure" >> $GITHUB_OUTPUT
              echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            fi
          else
            # Provide detailed error messages
            if [[ ! "$PR_TITLE" =~ : ]]; then
              ERROR_DETAIL="Missing ':' separator"
            elif [[ ! "$PR_TITLE" =~ ^($TYPES) ]]; then
              ERROR_DETAIL="Invalid or missing type prefix"
            elif [[ "$PR_TITLE" =~ ^($TYPES)(\(.+\))?:[[:space:]]*$ ]]; then
              ERROR_DETAIL="Missing description after ':'"
            else
              ERROR_DETAIL="Invalid format"
            fi
            
            MESSAGE="❌ **PR Title:** $ERROR_DETAIL. Current: \`$PR_TITLE\`. Expected: \`type: description\` (e.g., \`feat: add new feature\`)"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
          fi

  check-branch-name:
    name: 'Check Branch Name'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}
      summary: ${{ steps.check.outputs.summary }}
    steps:
      - name: Check Branch Name Format
        id: check
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          REGEX='^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)\/[a-z0-9-]+$'
          
          # Special branch names that are always valid
          if [[ "$BRANCH_NAME" = "dev" ]]; then
            MESSAGE="✅ **Branch Name:** Valid special branch (\`$BRANCH_NAME\`)"
            echo "$MESSAGE"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check against the regex
          if [[ "$BRANCH_NAME" =~ $REGEX ]]; then
            MESSAGE="✅ **Branch Name:** Follows naming convention (\`$BRANCH_NAME\`)"
            echo "$MESSAGE"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
          else
            # Provide specific feedback
            if [[ ! "$BRANCH_NAME" =~ / ]]; then
              ERROR_DETAIL="Missing '/' separator"
            elif [[ "$BRANCH_NAME" =~ ^[A-Z] ]]; then
              ERROR_DETAIL="Should not start with uppercase"
            elif [[ ! "$BRANCH_NAME" =~ ^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)\/ ]]; then
              ERROR_DETAIL="Invalid type prefix"
            elif [[ "$BRANCH_NAME" =~ [A-Z] ]]; then
              ERROR_DETAIL="Should not contain uppercase letters"
            else
              ERROR_DETAIL="Invalid format"
            fi
            
            MESSAGE="❌ **Branch Name:** $ERROR_DETAIL. Current: \`$BRANCH_NAME\`. Expected: \`type/description\` (e.g., \`feat/new-api\`)"
            echo "$MESSAGE"
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "summary=$MESSAGE" >> $GITHUB_OUTPUT
          fi

  report-summary:
    name: 'Report Summary'
    runs-on: ubuntu-latest
    needs:
      - check-commits
      - check-conflicts
      - check-pr-title
      - check-branch-name
    if: always()
    steps:
      - name: Build and Post Comment
        id: build_comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CHECKER_TOKEN }}
          script: |
            const outputs = {
              title: {
                status: ${{ toJSON(needs.check-pr-title.outputs.status) }},
                summary: ${{ toJSON(needs.check-pr-title.outputs.summary) }}
              },
              branch: {
                status: ${{ toJSON(needs.check-branch-name.outputs.status) }},
                summary: ${{ toJSON(needs.check-branch-name.outputs.summary) }}
              },
              commit: {
                status: ${{ toJSON(needs.check-commits.outputs.status) }},
                summary: ${{ toJSON(needs.check-commits.outputs.summary) }},
                report: ${{ toJSON(needs.check-commits.outputs.report) }}
              },
              conflicts: {
                status: ${{ toJSON(needs.check-conflicts.outputs.status) }},
                summary: ${{ toJSON(needs.check-conflicts.outputs.summary) }}
              }
            };
            
            let all_passed = true;
            let comment_body = "### 🛡️ PR Quality Check Summary\n\n";
            
            // Display the check results in order (using the summary generated by each job)
            comment_body += outputs.title.summary + "\n";
            comment_body += outputs.branch.summary + "\n";
            comment_body += outputs.commit.summary + "\n";
            comment_body += outputs.conflicts.summary + "\n";
            
            // Determine overall pass/fail
            if (outputs.title.status === 'failure' || 
                outputs.branch.status === 'failure' || 
                outputs.commit.status === 'failure' || 
                outputs.conflicts.status === 'failure') {
              all_passed = false;
            }

            // If commitlint failed, add detailed report in a collapsible section
            if (outputs.commit.status === 'failure' && outputs.commit.report) {
              comment_body += "\n<details><summary>📋 Click for detailed commitlint report</summary>\n\n";
              comment_body += "```\n" + outputs.commit.report + "\n```\n";
              comment_body += "</details>\n";
            }

            // Final overall status message
            if (all_passed) {
              comment_body += "\n---\n🎉 **All checks passed!** Ready to merge.";
            } else {
              comment_body += "\n---\n⚠️ **Please fix the failing checks (❌) before merging.**";
            }
            
            // Find existing comment and update to avoid duplication
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('🛡️ PR Quality Check Summary')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment_body
              });
              console.log('✅ Updated existing comment');
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment_body
              });
              console.log('✅ Created new comment');
            }
            
            core.setOutput('all_passed', all_passed ? 'true' : 'false');

      - name: Fail workflow if any check failed
        if: steps.build_comment.outputs.all_passed == 'false'
        run: |
          echo "❌ One or more PR quality checks failed. See summary comment for details."
          exit 1